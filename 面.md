###面试题
- ####ES6的新语法
	- `let / const` 
	> 和ES5的VAR区别
	>1) let 不存在变量提升机制（变量不允许在声明之前使用，会产生暂时性死区）
	>2) let 不允许重复声明
	>3）在全局作用中基于let声明的变量不是window的一个苏醒
	>4) typeof 未被声明的一个变量， =>不是undefined 而是报错
	>5) let 会形成块级作用域，类似于私有作用与，大部分大括号都会形成块级作用域
	- 结构赋值 :`let {name,age} = { title:xxx,name : xxx ,age: 20}`
	- `...`拓展、剩余、展开运算符
	- 箭头函数  `let fn = () =>{ }`
	>1.没有arguments，但是可以基于...arg获取实参集合（结果是一个数组）
	>2.没有自己的this，箭头函数中的this是上下文中的this
	-  ES6中的模板字符串
	- Promise：（`async/await`）异步处理
	- class() :es6中创建类的
	- interator（for of 循环）
	- Map / Set
#### 重排（回流） 重绘 的读写分离理解
- 思路：首先说出什么是重排和重绘，接着突出它们耗性能，最后突出自己写项目的时候重点注意了这些事情，以及自己的解决方案（说一下解决原理）
- 浏览器渲染一个页面的时候，是按照“先创建DOM树 -->再加载CSS -->生成渲染树 RENDER TREE -->把渲染树交给浏览器（GPU）进行绘制”，如果后期我们修改了元素的样式（但是没有改变大小和位置），浏览器会把当前元素重新生成渲染树，然后重新渲染，这个机制是重绘；但是一旦元素的位置或大小等发声改变，浏览器就要从DOM树重新开始计算渲染，这个机制是回流（重排），不论是重排还是重绘都非常的消耗性能
- 在我的以前项目中，我特意的充实了这个问题，尽量减少操作DOM引发的的回流和重绘问题，常用的解决方案：
	- 1.需要动态向页面追加元素的时候，基于文档碎片或者先把需要增加的所有元素拼接成字符串，最后统一进行增加
	- 2.读写分离：把统一修改样式都放到一起执行，新版浏览器都有一个自己的检测机制，如果发现下面紧挨着的操作也是修改元素的样式，会把所有修改的事先存起来，知道遇到非修改模式的操作，会把之前存储的统一执行，引发一次回流和重绘
	- 当然还有一些其他的办法，这些是最常注意的，我认为减少DOM的回流重绘是非常重要的性能优化手段之一。

#####用户昵称规定只能是“数字，大小写字母”组成，而且不能少于2位，也不能超过20位，写个正则匹配这需求
```
let reg = /^[0-9a-zA-Z]{2,20}$/

```

####谈谈对面向对象的理解！
- JS本身就是面向对象编程的
	- JS本身就是基于面向对象（OOP）编程思想开发出来的语言，我们学习JS就是在学习JS中的类和实例，例如：
	- 数组是Array的实例，对象是object的实例，函数时Function的实例...，在这些内置类的原型上右很多公共的属性和方法，这些方法可以被实例调用，我们学习JS就是学习这些方法
- 面向对象真实项目的应用
	-  平时的业务逻辑开发，我没有可以使用类的方法，只又在一些组件或者插件封装的时候才会基于构造函数和原型链使用类和实例完成；例如：我之前封装一些 TAB页卡、轮播图、模态框、表单验证等插件，就是这样处理的
- 面向对象中的一些语法和特点
	- 所谓面向对象就是基于class 或者function创建一个类，执行的时候new执行创建一个实例，这样实例就能调取类上提供的方法，想要基于面向对象进行插件封装，必须掌握关于类的继承、封装和多态，封装就提取公共方法，JS中没有严格意义的多态，不能进行方法的重写，常用的继承方法有很多，例如：原型 继承、寄生组合继承、es6中 的继承，有些方式会村子一些问题，我项目中 后来都是基于ckass中的extend实现继承的


####关于`THIS`
- 1.给元素的某个事件绑定方法，方法中的this 都是当前操作的元素本身
	- `document.body.onclick = function (){...} //this -->window`
- 2.函数执行，看函数名前面是否有点，有点的话，点前面是谁THIS就是谁，没有点，this就是`window`（在JS`严格模式（"use strict"`下，没有点this就是`undefined`）
- 3.构造函数：函数执行，this一般都是指向当前类的实例
```
let Fn = function (){
	this.x = 100
	}
let f = new Fn 
console.log(f.x) //=>100
```
- 4.箭头函数没有自己的this，this是上下文中的this
```
let obj = {
	Fn: function (){
		//this =>obj
		setTimeout(() => {
			//this:obj
			},1000)
	}
}
obj.Fn()
```
- 5.在小括号表达式中，会影响this的执行
```
let obj = {
	Fn : function (){
		console.log(this)
		}
	}
obj.Fn();//=>this:obj
(12,obj.Fn)()//=>this:window
```

- 6.使用call apply bind 改变this指向
- 7.定时器中的`回调函数`中的this指向window

####作用域链和原型链
- 作用域链：函数执行会形成一个私有的作用域，形参和在当前私有作用域中声明的变量都是私有变量，当前的私有作用域有自我保护机制，私有变量和外界是没有关系的，但是如果私有作用域中遇到一个非私有的变量，则向它的上级作用域找，如果还不是上级作用域私有的，则继续向上查找，一直找到window位置。这种变量一层层向上查找的机制就是“作用域链机制”
- 原型链：它也是一种查找机制，实例首先在自己的私有作用域中进行属性的查找，如果不是私有属性，基于`__proto__`向所属类的原型进行查找，如果再找不到，则继续基于`__proto__`向上查找，一直找到`Object.prototype`为止

####常用的算法
- 递归：函数自己调用自己执行就是递归 ：一个私有作用域套着一个私有作用域，若没有条件判断，则陷入死循环，浏览器报错超出最多栈内存个数
- 去重：  
- 冒泡排序
- 插入排序
- 快速排序
- 时间复杂度
- 空间复杂度
- KMP

####JQ的原理，怎么扩展插件
- JQ是一个JS类库，里面提供了很多常用的方法，有助于我们快速开发，而且这些方法是兼容所有浏览器的（V2 / V3 不兼容低版本浏览器）
- 我之前在学习原生JS的时候，或多或少的看了一部分JS源码，刚毕业的时候JQ用的比较多，但是最近两年一直都在用框架开发，JQ中常用的方法忘差不多了。之前看源码的时候，发现JQ就是一个类，而$()就是创建这个类的一个实例，这个实例是基于内置方法makeArray创建的类数组
- JQ提供的方法有两部分，一部分是放到原型上的，供实例调取使用，一部分是放到对象上的，直接$.xxx调取使用，想要后期自己扩展方法(包括基于JQ写插件)，都可以基于extend这个方法向JQ中扩展
- JQ中提供了动画、事件、ajax等常用的方法，我学习JQ源码的时候比较注重里面的一些封装和编程的思想。例如：发布订阅这种设计模式我就是一句JQ的$.callbacks学习研究的，所以学习JQ给我们带来了很多的好处...
####谈谈你对闭包的理解
- 闭包是JS中一个非常重要的机制，我们很多编程思想、业务逻辑、设计模式都是基于闭包完成的，先说一下我对闭包的理解，闭包就是函数执行产生一个私有的作用域（不销毁），在这个作用域中的私有变量和外界互不干扰，而且作用域（栈）不销毁，这些私有变量存储的值也都保留了下来，所以整体来说闭包就是为了保护和保存变量的
- 实际项目开发中，很多地方使用到了闭包，例如：
>1)循环事件绑定，由于事件绑定是异步编程，我们此时在循环的时候把索引存储起来（可以基于自定义属性存储，也可以基于闭包存储），后期需要使用的时候，向上级作用域查找使用即可
>2)平时做业务逻辑的时候，我一般都是基于单例模式来管理代码的,这种单例模式的构建就应用到了闭包
```
let xxxRender = (function(){
	return {
		init:function(){...}
		}
})()
```
>3)我之前在学习资料上了解了柯理化函数思想，它其实也是基于闭包完成的，函数原型bind方法实现的原理
```
Function.prototype.bind = function bind (context,...arg){
	return () =>{
		fn.call(context,...arg)
}
document.onclick = fn.bind(obj,10,20)
``` 
- **`缺点`**：
>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除
>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当做对象（`Object`）使用，把闭包当做它的公用方法（`public method`），把内部变量当做它的私有属性（`private value`），这时候一定要小心，不要随便改变父函数内部变量的值

	 
